Describe Async.Promise
  Before all
    let P = vital#vital#import('Async.Promise')

    " Constants
    let PENDING = 0
    let FULFILLED = 1
    let REJECTED = 2

    " Utilities
    let Wait = {ms -> P.new({res -> timer_start(ms, res)})}
    let ThrowAfter = {ms -> P.new({_, rej -> timer_start(ms, rej)})}
  End

  Describe .new()
    It creates a promise object with proper state
      let p = P.new({resolve -> resolve(0)})
      Assert Equals(p._state, FULFILLED)
      Assert HasKey(p, '_vital_promise')

      let p = P.new({_, reject -> reject(0)})
      Assert Equals(p._state, REJECTED)
      Assert HasKey(p, '_vital_promise')
    End

    It creates rejected promise object when an exception was thrown
      let p = P.new({_, reject -> execute('throw "error"')})
      Assert Equals(p._state, REJECTED)
    End
  End

  Describe .then()
    It calls its callback after synchronized resolution
      let l = l:
      let p = P.new({resolve -> resolve(42)})
      " Different from ES6 Promise
      Assert Equals(p._state, FULFILLED)
      let p = p.then({r -> extend(l, {'done' : r})})
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It calls its callback after asynchronized resolution
      let l = l:
      let p = Wait(50).then({-> extend(l, {'done' : 42})})
      sleep 100m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It resolves thenable object
      let l = l:
      let p = P.resolve(42).then({r -> P.resolve(r + 42)}).then({r -> extend(l, {'done' : r})})
      Assert Equals(done, 84)
      Assert Equals(p._state, FULFILLED)
    End

    It resolves thenable object asynchronously
      let l = l:
      let p = Wait(50).then({-> Wait(50)}).then({-> extend(l, {'done' : 42})})
      Assert Equals(p._state, PENDING)
      sleep 200m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It resolves by funcref directly
      let l = l:
      let p = P.resolve(50).then(Wait).then({-> extend(l, {'done' : 42})})
      Assert Equals(p._state, PENDING)
      sleep 100m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It can resolve the same promise more than once
      let l = l:
      let p = P.resolve(42)
      let p2 = p.then({v -> extend(l, {'done' : v + 10})})
      Assert Equals(done, 52)
      Assert Equals(p2._state, FULFILLED)
      let p2 = p.then({v -> extend(l, {'done' : v + 20})})
      Assert Equals(done, 62)
      Assert Equals(p2._state, FULFILLED)
    End

    It can resolve the same promise more than once asynchronously
      let l = l:
      let done = 100
      let p1 = Wait(50).then({-> 100})
      let p2 = p1.then({v -> extend(l, {'done' : l.done + v})})
      let p3 = p1.then({v -> extend(l, {'done' : l.done + v})})
      for p in [p1, p2, p3]
        Assert Equals(p._state, PENDING)
      endfor
      sleep 100m
      for p in [p1, p2, p3]
        Assert Equals(p._state, FULFILLED)
      endfor
      Assert Equals(done, 300)
    End
  End

  Describe .catch()
    It calls its callback after synchronized rejection
      let l = l:
      let p = P.new({_, reject -> reject(42)}).catch({r -> extend(l, {'done' : r})})
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It calls its callback after asynchronized rejection
      let l = l:
      let p = ThrowAfter(50)
        \.then({-> extend(l, {'done' : 1})})
        \.catch({-> extend(l, {'done' : 42})})
      sleep 100m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It is called when an exceptioin is thrown in upstream
      let l = l:
      let p = P.new({-> execute('throw 42')})
        \.catch({r -> extend(l, {'done' : r})})
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It resolves thenable object
      let l = l:
      let p = P.reject(42).catch({r -> P.resolve(r + 42)}).then({r -> extend(l, {'done' : r})})
      Assert Equals(done, 84)
      Assert Equals(p._state, FULFILLED)
    End

    It resolves thenable object asynchronously
      let l = l:
      let p = ThrowAfter(50).catch({-> ThrowAfter(50)}).catch({-> extend(l, {'done' : 42})})
      Assert Equals(p._state, PENDING)
      sleep 200m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It resolves by funcref directly
      let l = l:
      let p = P.reject(50).catch(Wait).then({-> extend(l, {'done' : 42})})
      Assert Equals(p._state, PENDING)
      sleep 100m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It can resolve the same rejected promise more than once
      let l = l:
      let p = P.reject(42)
      let p2 = p.catch({v -> extend(l, {'done' : v + 10})})
      Assert Equals(done, 52)
      Assert Equals(p2._state, FULFILLED)
      let p2 = p.catch({v -> extend(l, {'done' : v + 20})})
      Assert Equals(done, 62)
      Assert Equals(p2._state, FULFILLED)
    End

    It can resolve the same rejected promise more than once asynchronously
      let l = l:
      let done = 100
      let p1 = ThrowAfter(50)
      let p2 = p1.catch({v -> extend(l, {'done' : l.done + 100})})
      let p3 = p1.catch({v -> extend(l, {'done' : l.done + 100})})
      for p in [p1, p2, p3]
        Assert Equals(p._state, PENDING)
      endfor
      sleep 100m
      Assert Equals(p1._state, REJECTED)
      for p in [p2, p3]
        Assert Equals(p._state, FULFILLED)
      endfor
      Assert Equals(done, 300)
    End
  End

  Describe .all()
    It should make a promise resolving after all children resolved
      let l = l:
      let p1 = Wait(10)
      let p2 = Wait(200)
      let p3 = Wait(100)
      let done = 0
      let p4 = P.all([p1, p2, p3]).then({-> extend(l, {'done' : 1})})
      sleep 150m
      Assert Equals(done, 0)
      Assert Equals(p4._state, PENDING)
      sleep 150m
      Assert Equals(done, 1)
      Assert Equals(p4._state, FULFILLED)
    End

    It should reject promise immediately when one of children was rejected
      let l = l:
      let done = 0
      let p1 = Wait(10).then({ -> execute('throw 1') })
      let p2 = Wait(200)
      let p3 = P.all([p1, p2]).catch({r -> extend(l, {'done' : r})})
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p3._state, FULFILLED)
    End
  End

  Describe .race()
    It should make a promise resolving after first of children resolved
      let l = l:
      let p1 = Wait(10)
      let p2 = Wait(200)
      let done = 0
      let p4 = P.race([p1, p2]).then({-> extend(l, {'done' : 1})})
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p4._state, FULFILLED)
    End

    It should reject promise immediately when first child was rejected
      let l = l:
      let done = 0
      let p1 = Wait(10).then({ -> execute('throw 1') })
      let p2 = Wait(200)
      let p3 = P.race([p1, p2]).catch({r -> extend(l, {'done' : r})})
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p3._state, FULFILLED)
    End

    It should resolve promise even if succeeding promise is rejected
      let p1 = Wait(10)
      let p2 = ThrowAfter(200)
      let p3 = P.race([p1, p2])
      sleep 100m
      Assert Equals(p3._state, FULFILLED)
    End
  End

  Describe .resolve()
    It creates resolved Promise with given non-Promise value
      let l = l:
      for v in [42, 'foo', {'foo': 42}, {}, v:null, v:true, v:false, v:none]
        let p = P.resolve(v)
        Assert Equals(p._state, FULFILLED)
        call p.then({v -> extend(l, {'done' : v})})
        Assert Equals(done, v)
        unlet l:done
      endfor
    End

    It creates resolved Promise with given Promise value
      let p = P.resolve(P.resolve(42))
      Assert Equals(p._state, FULFILLED)
    End

    It creates rejected Promise with rejected Promise value
      let p = P.resolve(P.reject(42))
      Assert Equals(p._state, REJECTED)
    End
  End

  Describe .reject()
    It creates rejected Promise with non-Promise value
      let l = l:
      for v in [42, 'foo', {'foo': 42}, {}, v:null, v:true, v:false, v:none]
        let p = P.reject(v)
        Assert Equals(p._state, REJECTED)
        call p.catch({v -> extend(l, {'done' : v})})
        Assert Equals(done, v)
        unlet l:done
      endfor
    End

    It creates rejected Promise with resolved Promise
      let p = P.reject(P.resolve(42))
      Assert Equals(p._state, REJECTED)
    End

    It creates rejected Promise with rejected Promise
      let p = P.reject(P.reject(42))
      Assert Equals(p._state, REJECTED)
    End
  End

  Describe .is_available()
    It should return true on Vim8 or Neovim
      Assert True(P.is_available())
    End
  End

  Describe is_promise()
    It should return a given value is Promise instance or not
      Assert True(P.is_promise(P.resolve(42)))
      Assert False(P.is_promise({}))
      Assert False(P.is_promise(v:null))
      Assert False(P.is_promise(42))
    End
  End
End

" vim:et ts=2 sts=2 sw=2 tw=0:
