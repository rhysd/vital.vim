Describe Async.Promise
  Before all
    let P = vital#vital#import('Async.Promise')

    " Constants
    let PENDING = 0
    let FULFILLED = 1
    let REJECTED = 2

    " Utilities
    let Wait = {ms -> P.new({res -> timer_start(ms, res)})}
    let ThrowAfter = {ms -> P.new({_, rej -> timer_start(ms, rej)})}
  End

  Describe .new()
    It creates a promise object with proper state
      let p = P.new({resolve -> resolve(0)})
      Assert Equals(p._state, FULFILLED)
      Assert HasKey(p, '_vital_promise')

      let p = P.new({_, reject -> reject(0)})
      Assert Equals(p._state, REJECTED)
      Assert HasKey(p, '_vital_promise')
    End

    It creates rejected promise object when an exception was thrown
      let p = P.new({_, reject -> execute('throw "error"')})
      Assert Equals(p._state, REJECTED)
    End
  End

  Describe .then()
    It calls its callback after synchronized resolution
      let l = l:
      let p = P.new({resolve -> resolve(42)}).then({r -> extend(l, {'done' : r})})
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It calls its callback after asynchronized resolution
      let l = l:
      let p = Wait(50).then({-> extend(l, {'done' : 42})})
      sleep 100m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End
  End

  Describe .catch()
    It calls its callback after synchronized rejection
      let l = l:
      let p = P.new({_, reject -> reject(42)}).catch({r -> extend(l, {'done' : r})})
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It calls its callback after asynchronized rejection
      let l = l:
      let p = ThrowAfter(50)
        \.then({-> extend(l, {'done' : 1})})
        \.catch({-> extend(l, {'done' : 42})})
      sleep 100m
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End

    It is called when an exceptioin is thrown in upstream
      let l = l:
      let p = P.new({-> execute('throw 42')})
        \.catch({r -> extend(l, {'done' : r})})
      Assert Equals(done, 42)
      Assert Equals(p._state, FULFILLED)
    End
  End

  Describe .all()
    It should make a promise resolving after all children resolved
      let l = l:
      let p1 = Wait(50)
      let p2 = Wait(150)
      let p3 = Wait(100)
      let done = 0
      let p4 = P.all([p1, p2, p3]).then({-> extend(l, {'done' : 1})})
      sleep 100m
      Assert Equals(done, 0)
      Assert Equals(p4._state, PENDING)
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p4._state, FULFILLED)
    End

    It should reject promise immediately when one of children was rejected
      let l = l:
      let done = 0
      let p1 = Wait(50).then({ -> execute('throw 1') })
      let p2 = Wait(150)
      let p3 = P.all([p1, p2]).catch({r -> extend(l, {'done' : r})})
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p3._state, FULFILLED)
    End
  End

  Describe .race()
    It should make a promise resolving after first of children resolved
      let l = l:
      let p1 = Wait(50)
      let p2 = Wait(150)
      let done = 0
      let p4 = P.race([p1, p2]).then({-> extend(l, {'done' : 1})})
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p4._state, FULFILLED)
    End

    It should reject promise immediately when first child was rejected
      let l = l:
      let done = 0
      let p1 = Wait(50).then({ -> execute('throw 1') })
      let p2 = Wait(150)
      let p3 = P.race([p1, p2]).catch({r -> extend(l, {'done' : r})})
      sleep 100m
      Assert Equals(done, 1)
      Assert Equals(p3._state, FULFILLED)
    End

    It should resolve promise even if succeeding promise is rejected
      let p1 = Wait(50)
      let p2 = ThrowAfter(70)
      let p3 = P.race([p1, p2])
      sleep 100m
      Assert Equals(p3._state, FULFILLED)
    End
  End

  Describe .resolve()
    It creates resolved promise
      let l = l:
      let p = P.resolve(42)
      Assert Equals(p._state, FULFILLED)
      call p.then({v -> extend(l, {'done' : v})})
      Assert Equals(done, 42)
    End
  End

  Describe .reject()
    It creates rejected promise
      let l = l:
      let p = P.reject(42)
      Assert Equals(p._state, REJECTED)
      call p.catch({v -> extend(l, {'done' : v})})
      Assert Equals(done, 42)
    End
  End

  Describe .is_available()
    It should return true on Vim8 or Neovim
      Assert True(P.is_available())
    End
  End

  Describe is_promise()
    It should return a given value is Promise instance or not
      Assert True(P.is_promise(P.resolve(42)))
      Assert False(P.is_promise({}))
      Assert False(P.is_promise(v:null))
      Assert False(P.is_promise(42))
    End
  End
End

" vim:et ts=2 sts=2 sw=2 tw=0:
